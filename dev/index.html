<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · StructTypes.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StructTypes.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/StructTypes.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="StructTypes.jl-1" href="#StructTypes.jl-1">StructTypes.jl</a></h1><ul><li><a href="#StructTypes.AbstractType"><code>StructTypes.AbstractType</code></a></li><li><a href="#StructTypes.ArrayType"><code>StructTypes.ArrayType</code></a></li><li><a href="#StructTypes.BoolType"><code>StructTypes.BoolType</code></a></li><li><a href="#StructTypes.DataType"><code>StructTypes.DataType</code></a></li><li><a href="#StructTypes.DictType"><code>StructTypes.DictType</code></a></li><li><a href="#StructTypes.InterfaceType"><code>StructTypes.InterfaceType</code></a></li><li><a href="#StructTypes.Mutable"><code>StructTypes.Mutable</code></a></li><li><a href="#StructTypes.NoStructType"><code>StructTypes.NoStructType</code></a></li><li><a href="#StructTypes.NullType"><code>StructTypes.NullType</code></a></li><li><a href="#StructTypes.NumberType"><code>StructTypes.NumberType</code></a></li><li><a href="#StructTypes.StringType"><code>StructTypes.StringType</code></a></li><li><a href="#StructTypes.Struct"><code>StructTypes.Struct</code></a></li><li><a href="#StructTypes.StructType"><code>StructTypes.StructType</code></a></li><li><a href="#StructTypes.applyfield!-Union{Tuple{T}, Tuple{Any,T,Symbol}} where T"><code>StructTypes.applyfield!</code></a></li><li><a href="#StructTypes.construct-Union{Tuple{T}, Tuple{Any,Type{T}}} where T"><code>StructTypes.construct</code></a></li><li><a href="#StructTypes.excludes"><code>StructTypes.excludes</code></a></li><li><a href="#StructTypes.fieldprefix"><code>StructTypes.fieldprefix</code></a></li><li><a href="#StructTypes.foreachfield-Union{Tuple{T}, Tuple{Any,T}} where T"><code>StructTypes.foreachfield</code></a></li><li><a href="#StructTypes.idproperty"><code>StructTypes.idproperty</code></a></li><li><a href="#StructTypes.keywordargs"><code>StructTypes.keywordargs</code></a></li><li><a href="#StructTypes.mapfields!-Union{Tuple{T}, Tuple{Any,T}} where T"><code>StructTypes.mapfields!</code></a></li><li><a href="#StructTypes.names"><code>StructTypes.names</code></a></li><li><a href="#StructTypes.omitempties"><code>StructTypes.omitempties</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.AbstractType" href="#StructTypes.AbstractType"><code>StructTypes.AbstractType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.AbstractType()</code></pre><p>Signal that <code>T</code> is an abstract type, and when deserializing, one of its concrete subtypes will be materialized, based on a &quot;type&quot; key/field in the serialization object.</p><p>Thus, <code>StructTypes.AbstractType</code>s <em>must</em> define <code>StructTypes.subtypes</code>, which should be a NamedTuple with subtype keys mapping to concrete Julia subtype values. You may optionally define <code>StructTypes.subtypekey</code> that indicates which input key/field name should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this <code>StructType</code>:</p><pre><code class="language-julia">abstract type Vehicle end

struct Car &lt;: Vehicle
    type::String
    make::String
    model::String
    seatingCapacity::Int
    topSpeed::Float64
end

struct Truck &lt;: Vehicle
    type::String
    make::String
    model::String
    payloadCapacity::Float64
end

StructTypes.StructType(::Type{Vehicle}) = StructTypes.AbstractType()
StructTypes.StructType(::Type{Car}) = StructTypes.Struct()
StructTypes.StructType(::Type{Truck}) = StructTypes.Struct()
StructTypes.subtypekey(::Type{Vehicle}) = :type
StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)

# example from StructTypes deserialization
car = StructTypes.read(&quot;&quot;&quot;
{
    &quot;type&quot;: &quot;car&quot;,
    &quot;make&quot;: &quot;Mercedes-Benz&quot;,
    &quot;model&quot;: &quot;S500&quot;,
    &quot;seatingCapacity&quot;: 5,
    &quot;topSpeed&quot;: 250.1
}&quot;&quot;&quot;, Vehicle)</code></pre><p>Here we have a <code>Vehicle</code> type that is defined as a <code>StructTypes.AbstractType()</code>. We also have two concrete subtypes, <code>Car</code> and <code>Truck</code>. In addition to the <code>StructType</code> definition, we also define <code>StructTypes.subtypekey(::Type{Vehicle}) = :type</code>, which signals that when deserializing, when it encounters the <code>type</code> key, it should use the ***value***, in the above example: <code>car</code>, to discover the appropriate concrete subtype to parse the structure as, in this case <code>Car</code>. The mapping of subtype key value to concrete Julia subtype is defined in our example via <code>StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)</code>. Thus, <code>StructTypes.AbstractType</code> is useful when the object to deserialize includes a &quot;subtype&quot; key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a <code>Car</code> instead of a <code>Truck</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL424-L475">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.ArrayType" href="#StructTypes.ArrayType"><code>StructTypes.ArrayType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.ArrayType()</code></pre><p>Declare that <code>T</code> should map to an array of ordered elements, homogenous or otherwise.</p><p>Types already declared as <code>StructTypes.ArrayType()</code> include:</p><ul><li>Any subtype of <code>AbstractArray</code></li><li>Any subtype of <code>AbstractSet</code></li><li>Any <code>Tuple</code> type</li></ul><p>So if your type already subtypes these and satifies their interface, things should just work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.ArrayType()</code> for deserializing is:</p><ul><li><code>T(x::Vector)</code>: implement a constructor that takes a <code>Vector</code> argument of values and constructs a <code>T</code></li><li><code>StructTypes.construct(::Type{T}, x::Vecto; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor isn&#39;t possible</li><li>Optional: <code>Base.IteratorEltype(::Type{T}) = Base.HasEltype()</code> and <code>Base.eltype(x::T)</code>: this can be used to signal that elements for your type are expected to be a homogenous type</li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>iterate(x::T)</code>: just iteration over each element is required; note if you subtype <code>AbstractArray</code> and define <code>getindex(x::T, i::Int)</code>, then iteration is inherited for your type</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL262-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.BoolType" href="#StructTypes.BoolType"><code>StructTypes.BoolType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.BoolType()</code></pre><p>Declare that <code>T</code> should map to a boolean value.</p><p>Types already declared as <code>StructTypes.BoolType()</code> include:</p><ul><li><code>Bool</code></li></ul><p>The interface to satisfy for deserializing is:</p><ul><li><code>T(x::Bool)</code>: define a constructor that takes a single <code>Bool</code> value</li><li><code>StructTypes.construct(::Type{T}, x::Bool; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>Bool(x::T)</code>: define a conversion to <code>Bool</code> method</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL383-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.DataType" href="#StructTypes.DataType"><code>StructTypes.DataType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A kind of <code>StructType</code> where an object&#39;s &quot;data&quot; is made up, at least in part, by its direct fields. When serializing, appropriate fields will be accessed directly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.DictType" href="#StructTypes.DictType"><code>StructTypes.DictType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.DictType()</code></pre><p>Declare that <code>T</code> should map to a dict-like object of unordered key-value pairs, where keys are <code>Symbol</code>, <code>String</code>, or <code>Int64</code>, and values are any other type (or <code>Any</code>).</p><p>Types already declared as <code>StructTypes.DictType()</code> include:</p><ul><li>Any subtype of <code>AbstractDict</code></li><li>Any <code>NamedTuple</code> type</li><li>The <code>Pair</code> type</li></ul><p>So if your type subtypes <code>AbstractDict</code> and implements its interface, then it will inherit the <code>DictType</code> definition and serializing/deserializing should work automatically.</p><p>Otherwise, the interface to satisfy <code>StructTypes.DictType()</code> for deserializing is:</p><ul><li><code>T(x::Dict{Symbol, Any})</code>: implement a constructor that takes a <code>Dict{Symbol, Any}</code> of input key-value pairs</li><li><code>StructTypes.construct(::Type{T}, x::Dict; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)</li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>pairs(x)</code>: implement the <code>pairs</code> iteration function (from Base) to iterate key-value pairs to be serialized</li><li><code>StructTypes.keyvaluepairs(x::T)</code>: alternatively, you can overload the <code>StructTypes.keyvaluepairs</code> function if overloading <code>pairs</code> isn&#39;t possible for whatever reason</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL224-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.InterfaceType" href="#StructTypes.InterfaceType"><code>StructTypes.InterfaceType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.InterfaceType</code></pre><p>An abstract type used in the API for &quot;interface types&quot; to map Julia types to a &quot;standard&quot; set of common types. See docs for the following concrete subtypes for more details:</p><ul><li>StructTypes.DictType</li><li>StructTypes.ArrayType</li><li>StructTypes.StringType</li><li>StructTypes.NumberType</li><li>StructTypes.BoolType</li><li>StructTypes.NullType</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL210-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.Mutable" href="#StructTypes.Mutable"><code>StructTypes.Mutable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.Mutable()</code></pre><p>Signal that <code>T</code> is a mutable struct with an empty constructor for serializing/deserializing. Though slightly less performant than <code>StructTypes.Struct</code>, <code>Mutable</code> is a much more robust method for mapping Julia struct fields for serialization. This technique requires your Julia type to be defined, ***at a minimum***, like:</p><pre><code class="language-julia">mutable struct T
    field1
    field2
    field3
    # etc.

    T() = new()
end</code></pre><p>Note specifically that we&#39;re defining a <code>mutable struct</code> to allow field mutation, and providing a <code>T() = new()</code> inner constructor which constructs an &quot;empty&quot; <code>T</code> where <code>isbitstype</code> fields will be randomly initialized, and reference fields will be <code>#undef</code>. (Note that the inner constructor doesn&#39;t need to be ***exactly*** this, but at least needs to be callable like <code>T()</code>. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the inner constructor). For these mutable types, the type will first be initizlied like <code>T()</code>, then serialization will take each key-value input pair, setting the field as the key is encountered, and converting the value to the appropriate field value. This flow has the nice properties of: allowing object construction success even if fields are missing in the input, and if &quot;extra&quot; fields exist in the input that aren&#39;t apart of the Julia struct&#39;s fields, they will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary data foramts that may be generated via web services, databases, other language libraries, etc.</p><p>There are a few additional helper methods that can be utilized by <code>StructTypes.Mutable()</code> types to hand-tune field reading/writing behavior:</p><ul><li><code>StructTypes.names(::Type{T}) = ((:juliafield1, :serializedfield1), (:juliafield2, :serializedfield2))</code>: provides a mapping of Julia field name to expected serialized object key name. This affects both serializing and deserializing. When deserializing the <code>serializedfield1</code> key, the <code>juliafield1</code> field of <code>T</code> will be set. When serializing the <code>juliafield2</code> field of <code>T</code>, the output key will be <code>serializedfield2</code>. Field name mappings are provided as a <code>Tuple</code> of <code>Tuple{Symbol, Symbol}</code>s, i.e. each field mapping is a Julia field name <code>Symbol</code> (first) and serialized field name <code>Symbol</code> (second).</li><li><code>StructTypes.excludes(::Type{T}) = (:field1, :field2)</code>: specify fields of <code>T</code> to ignore when serializing and deserializing, provided as a <code>Tuple</code> of <code>Symbol</code>s. When deserializing, if <code>field1</code> is encountered as an input key, it&#39;s value will be read, but the field will not be set in <code>T</code>. When serializing, <code>field1</code> will be skipped when serializing out <code>T</code> fields as key-value pairs.</li><li><code>StructTypes.omitempties(::Type{T}) = (:field1, :field2)</code>: specify fields of <code>T</code> that shouldn&#39;t be serialized if they are &quot;empty&quot;, provided as a <code>Tuple</code> of <code>Symbol</code>s. This only affects serializing. If a field is a collection (AbstractDict, AbstractArray, etc.) and <code>isempty(x) === true</code>, then it will not be serialized. If a field is <code>#undef</code>, it will not be serialized. If a field is <code>nothing</code>, it will not be serialized.</li><li><code>StructTypes.keywordargs(::Type{T}) = (field1=(dateformat=dateformat&quot;mm/dd/yyyy&quot;,), field2=(dateformat=dateformat&quot;HH MM SS&quot;,))</code>: provide keyword arguments for fields of type <code>T</code> that should be passed to the constructor method of the field. Define <code>StructTypes.keywordargs</code> as a NamedTuple of NamedTuples.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL45-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.NoStructType" href="#StructTypes.NoStructType"><code>StructTypes.NoStructType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Default <code>StructTypes.StructType</code> for types that don&#39;t have a <code>StructType</code> defined; this ensures objects must have an explicit <code>StructType</code> to avoid unanticipated issues</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.NullType" href="#StructTypes.NullType"><code>StructTypes.NullType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.NullType()</code></pre><p>Declare that <code>T</code> should map to a &quot;null&quot; value.</p><p>Types already declared as <code>StructTypes.NullType()</code> include:</p><ul><li><code>nothing</code></li><li><code>missing</code></li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>T()</code>: an empty constructor for <code>T</code></li><li><code>StructTypes.construct(::Type{T}, x::Nothing; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>There is no interface for serializing; if a custom type is declared as <code>StructTypes.NullType()</code>, then serializing will be handled specially; writing <code>null</code> in JSON, <code>NULL</code> in SQL, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL403-L417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.NumberType" href="#StructTypes.NumberType"><code>StructTypes.NumberType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.NumberType()</code></pre><p>Declare that <code>T</code> should map to a number value.</p><p>Types already declared as <code>StructTypes.NumberType()</code> include:</p><ul><li>Any subtype of <code>Signed</code></li><li>Any subtype of <code>Unsigned</code></li><li>Any subtype of <code>AbstractFloat</code></li></ul><p>In addition to declaring <code>StructTypes.NumberType()</code>, custom types can also specify a specific, ***existing*** number type it should map to. It does this like:</p><pre><code class="language-julia">StructTypes.numbertype(::Type{T}) = Float64</code></pre><p>In this case, <code>T</code> declares it should map to an already-supported number type: <code>Float64</code>. This means that when deserializing, an input will be parsed/read/deserialiezd as a <code>Float64</code> value, and then call <code>T(x::Float64)</code>. Note that custom types may also overload <code>StructTypes.construct(::Type{T}, x::Float64; kw...)</code> if using a constructor isn&#39;t possible. Also note that the default for any type declared as <code>StructTypes.NumberType()</code> is <code>Float64</code>.</p><p>Similarly for serializing, <code>Float64(x::T)</code> will first be called before serializing the resulting <code>Float64</code> value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL355-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.StringType" href="#StructTypes.StringType"><code>StructTypes.StringType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.StringType()</code></pre><p>Declare that <code>T</code> should map to a string value.</p><p>Types already declared as <code>StructTypes.StringType()</code> include:</p><ul><li>Any subtype of <code>AbstractString</code></li><li>The <code>Symbol</code> type</li><li>Any subtype of <code>Enum</code> (values are written with their symbolic name)</li><li>Any subtype of <code>AbstractChar</code></li><li>The <code>UUID</code> type</li><li>Any <code>Dates.TimeType</code> subtype (<code>Date</code>, <code>DateTime</code>, <code>Time</code>, etc.)</li></ul><p>So if your type is an <code>AbstractString</code> or <code>Enum</code>, then things should already work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.StringType()</code> for deserializing is:</p><ul><li><code>T(x::String)</code>: define a constructor for your type that takes a single String argument</li><li><code>StructTypes.construct(::Type{T}, x::String; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code> for your type</li><li><code>StructTypes.construct(::Type{T}, ptr::Ptr{UInt8}, len::Int; kw...)</code>: another option is to overload <code>StructTypes.construct</code> with pointer and length arguments, if it&#39;s possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both <code>StructTypes.construct</code> methods, since direct pointer/length deserialization may not be possible for some inputs</li></ul><p>The interface to satisfy for serializing is:</p><ul><li><code>Base.string(x::T)</code>: overload <code>Base.string</code> for your type to return a &quot;stringified&quot; value, or more specifically, that returns an <code>AbstractString</code>, and should implement <code>ncodeunits(x)</code> and <code>codeunit(x, i)</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL292-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.Struct" href="#StructTypes.Struct"><code>StructTypes.Struct</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StructTypes.StructType(::Type{T}) = StructTypes.Struct()</code></pre><p>Signal that <code>T</code> can participate in a simplified, performant struct serialization by relying on reliable field order when serializing/deserializing. In particular, when deserializing, parsed input fields are passed directly, in input order to the <code>T</code> constructor, like <code>T(field1, field2, field3)</code>. This means that any field names are ignored when deserializing; fields are directly passed to <code>T</code> in the order they&#39;re encountered.</p><p>For example, for reading a <code>StructTypes.Struct()</code> from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like <code>T(val1, val2, val3)</code>. Yes, the JSON specification says that Objects are specifically ***un-ordered*** collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the &quot;trusting&quot; that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of <code>StructTypes.Struct()</code> in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren&#39;t anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the <code>StructTypes.Mutable()</code> option.</p><pre><code class="language-">struct CoolType
    val1::Int
    val2::Int
    val3::String
end

StructTypes.StructType(::Type{CoolType}) = StructTypes.Struct()

# StructTypes package as example
@assert StructTypes.read(&quot;{&quot;val1&quot;: 1, &quot;val2&quot;: 2, &quot;val3&quot;: 3}&quot;, CoolType) == CoolType(1, 2, &quot;3&quot;)
# note how `val2` field is first, then `val1`, but fields are passed *in-order* to `CoolType` constructor; BE CAREFUL!
@assert StructTypes.read(&quot;{&quot;val2&quot;: 2, &quot;val1&quot;: 1, &quot;val3&quot;: 3}&quot;, CoolType) == CoolType(2, 1, &quot;3&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL14-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.StructType" href="#StructTypes.StructType"><code>StructTypes.StructType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Abstract super type of various <code>StructType</code>s; see <code>StructTypes.DataType</code>, <code>StructTypes.InterfaceType</code>, and <code>StructTypes.AbstractType</code> for more specific kinds of <code>StructType</code>s</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.applyfield!-Union{Tuple{T}, Tuple{Any,T,Symbol}} where T" href="#StructTypes.applyfield!-Union{Tuple{T}, Tuple{Any,T,Symbol}} where T"><code>StructTypes.applyfield!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StructTypes.applyfield!(f, x::T, nm::Symbol) =&gt; Bool</code></pre><p>Convenience function for working with a <code>StructTypes.Mutable</code> object. For a given serialization name <code>nm</code>, apply the function <code>f(i, name, FT)</code> to the field index <code>i</code>, field name <code>name</code>, and field type <code>FT</code>, setting the field value to the return value of <code>f</code>. Various StructType configurations are respected like keyword arguments, names, and exclusions. <code>applyfield!</code> returns whether <code>f</code> was executed or not; if <code>nm</code> isn&#39;t a valid field name on <code>x</code>, <code>false</code> will be returned (important for applications where the input still needs to consume the field, like json parsing). Note that the input <code>nm</code> is treated as the serialization name, so any <code>StructTypes.names</code> mappings will be applied, and the function will be passed the Julia field name.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL625-L636">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.construct-Union{Tuple{T}, Tuple{Any,Type{T}}} where T" href="#StructTypes.construct-Union{Tuple{T}, Tuple{Any,Type{T}}} where T"><code>StructTypes.construct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StructTypes.construct(f, T) =&gt; T</code></pre><p>Apply function <code>f(i, name, FT)</code> over each field index <code>i</code>, field name <code>name</code>, and field type <code>FT</code> of type <code>T</code>, passing the function results to <code>T</code> for construction, like <code>T(x_1, x_2, ...)</code>. Note that any <code>StructTypes.names</code> mappings are applied, as well as field-specific keyword arguments via <code>StructTypes.keywordargs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL485-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.excludes" href="#StructTypes.excludes"><code>StructTypes.excludes</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">StructTypes.excludes(::Type{T}) = (:field1, :field2)</code></pre><p>Specify for a <code>StructTypes.Mutable</code> <code>StructType</code> the fields, given as a <code>Tuple</code> of <code>Symbol</code>s, that should be ignored when deserializing, and excluded from serializing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL107-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.fieldprefix" href="#StructTypes.fieldprefix"><code>StructTypes.fieldprefix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">StructTypes.fieldprefix(::Type{MyType}) = :mytype_</code></pre><p>When interacting with database tables and other strictly 2D data formats, objects with aggregate fields must be flattened into a single set of column names. When deserializing a set of columns into an object with aggregate fields, a field type&#39;s <code>fieldprefix</code> signals that column names beginning with, in the example above, <code>:mytype_</code>, should be collected together when constructing <code>MyType</code>.</p><p>Here&#39;s a more concrete, albeit contrived, example:</p><pre><code class="language-julia">struct Spouse
    id::Int
    name::String
end

StructTypes.StructType(::Type{Spouse}) = StructTypes.Struct()
StructTypes.fieldprefix(::Type{Spouse}) = :spouse_

struct Person
    id::Int
    name::String
    spouse::Person
end

StructTypes.StructType(::Type{Person}) = StructTypes.Struct()</code></pre><p>Here we have two structs, <code>Spouse</code> and <code>Person</code>, and a <code>Person</code> has a <code>spouse::Spouse</code>. The database tables to represent these entities might look like:</p><pre><code class="language-SQL">CREATE TABLE spouse (id INT, name VARCHAR);
CREATE TABLE person (id INT, name VARCHAR, spouse_id INT);</code></pre><p>If we want to leverage a package like ORM.jl to automatically handle the object construction for us, we could write a get query like the following to ensure a full <code>Person</code> with field <code>spouse::Spouse</code> can be constructed:</p><pre><code class="language-julia">getPerson(id::Int) = ORM.select(db,
    &quot;&quot;&quot;
        SELECT person.id as id, person.name as name, spouse.id as spouse_id, spouse.name as spouse_name
        FROM person
        LEFT JOIN spouse ON person.spouse_id = spouse.id
        WHERE person.id = $id
    &quot;&quot;&quot;, Person)</code></pre><p>This works because the column names in the resultset of this query are &quot;id, name, spouse<em>id, spouse</em>name&quot;; because we defined <code>StructTypes.fieldprefix(::Type{Spouse}) = :spouse_</code>, ORM.jl knows that each column starting with &quot;spouse_&quot; should be used in constructing <code>Spouse</code> instead of <code>Person</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL160-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.foreachfield-Union{Tuple{T}, Tuple{Any,T}} where T" href="#StructTypes.foreachfield-Union{Tuple{T}, Tuple{Any,T}} where T"><code>StructTypes.foreachfield</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StructTypes.foreachfield(f, x::T) =&gt; Nothing</code></pre><p>Apply function <code>f(i, name, FT, v)</code> over each field index <code>i</code>, field name <code>name</code>, field type <code>FT</code>, and field value <code>v</code> in <code>x</code>. Nothing is returned and results from <code>f</code> are ignored. Similar to <code>Base.foreach</code> over collections.</p><p>Various &quot;configurations&quot; are respected when applying <code>f</code> to each field:</p><ul><li>If keyword arguments have been defined for a field via <code>StructTypes.keywordargs</code>, they will be passed like <code>f(i, name, FT, v; kw...)</code></li><li>If <code>StructTypes.names</code> has been defined, <code>name</code> will be the serialization name instead of the defined julia field name</li><li>If a field is undefined or empty and <code>StructTypes.omitempties</code> is defined, <code>f</code> won&#39;t be applied to that field</li><li>If a field has been excluded via <code>StructTypes.excludes</code>, it will be skipped</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL530-L541">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.idproperty" href="#StructTypes.idproperty"><code>StructTypes.idproperty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">StructTypes.idproperty(::Type{MyType}) = :id</code></pre><p>Specify which field of a type uniquely identifies it. The unique identifier field name is given as a Symbol. Useful in database applications where the id field can be used to distinguish separate objects.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL149-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.keywordargs" href="#StructTypes.keywordargs"><code>StructTypes.keywordargs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">StructTypes.keywordargs(::Type{MyType}) = (field1=(dateformat=dateformat&quot;mm/dd/yyyy&quot;,), field2=(dateformat=dateformat&quot;HH MM SS&quot;,))</code></pre><p>Specify for a <code>StructTypes.Mutable</code> the keyword arguments by field, given as a <code>NamedTuple</code> of <code>NamedTuple</code>s, that should be passed to the <code>StructTypes.construct</code> method when deserializing <code>MyType</code>. This essentially allows defining specific keyword arguments you&#39;d like to be passed for each field in your struct. Note that keyword arguments can be passed when reading, like <code>JSON3.read(source, MyType; dateformat=...)</code> and they will be passed down to each <code>StructTypes.construct</code> method. <code>StructTypes.keywordargs</code> just allows the defining of specific keyword arguments per field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL136-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.mapfields!-Union{Tuple{T}, Tuple{Any,T}} where T" href="#StructTypes.mapfields!-Union{Tuple{T}, Tuple{Any,T}} where T"><code>StructTypes.mapfields!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StructTypes.mapfields!(f, x::T)</code></pre><p>Applys the function <code>f(i, name, FT)</code> to each field index <code>i</code>, field name <code>name</code>, and field type <code>FT</code> of <code>x</code>, and calls <code>setfield!(x, name, y)</code> where <code>y</code> is returned from <code>f</code>.</p><p>This is a convenience function for working with <code>StructTypes.Mutable</code>, where a function can be applied over the fields of the mutable struct to set each field value. It respects the various StructTypes configurations in terms of skipping/naming/passing keyword arguments as defined.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL582-L591">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.names" href="#StructTypes.names"><code>StructTypes.names</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">StructTypes.names(::Type{T}) = ((:juliafield1, :serializedfield1), (:juliafield2, :serializedfield2))</code></pre><p>Provides a mapping of Julia field name to expected serialized object key name. This affects both reading and writing. When reading the <code>serializedfield1</code> key, the <code>juliafield1</code> field of <code>T</code> will be set. When writing the <code>juliafield2</code> field of <code>T</code>, the output key will be <code>serializedfield2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL76-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructTypes.omitempties" href="#StructTypes.omitempties"><code>StructTypes.omitempties</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">StructTypes.omitempties(::Type{T}) = (:field1, :field2)</code></pre><p>Specify for a <code>StructTypes.Mutable</code> <code>StructType</code> the fields, given as a <code>Tuple</code> of <code>Symbol</code>s, that should not be serialized if they&#39;re considered &quot;empty&quot;. If a field is a collection (AbstractDict, AbstractArray, etc.) and <code>isempty(x) === true</code>, then it will not be serialized. If a field is <code>#undef</code>, it will not be serialized. If a field is <code>nothing</code>, it will not be serialized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/StructTypes.jl/blob/da611396da7d262c5f5ce310cba9d697bf83416c/src/StructTypes.jl#LL117-L122">source</a></section><footer><hr/></footer></article></body></html>
